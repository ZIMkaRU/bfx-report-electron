<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <meta http-equiv="Cache-Control" content="no-store" />
  <meta http-equiv="Expires" content="0" />
  <meta name="description" content="Manage risk, money & strategies with our state-of-the-art pro reporting tools" />

  <title>Bitfinex Reporting & Performance Tools</title>

  <link rel="manifest" href="manifest.json" crossorigin="use-credentials" />
  <link rel="shortcut icon" href="favicon.ico" />
  <style>
    * {
      transition: all 0.5s; 
    }

    html {
      height: 100%;
    }

    .body {
      position: relative;
      height: 100%;
      padding: 0;
      margin: 0;
      text-align: center;
      background-color: #394b59;
    }

    .output {
      text-align: left;
      padding: 20px;
      margin-top: 15px;
      background-color: #2e3c47;
      position: relative;
    }

    .input {
      margin-top: 10px;
      text-align: center;
      padding-right: 10px;
      box-shadow: 0 0 0 0 rgba(19,124,189,0), 0 0 0 0 rgba(19,124,189,0), 0 0 0 0 rgba(19,124,189,0), inset 0 0 0 1px rgba(16,22,26,.3), inset 0 1px 1px rgba(16,22,26,.4);
      background: rgba(16,22,26,.3);
      color: #f5f8fa;
      position: relative;
      outline: none;
      border: none;
      border-radius: 3px;
      height: 30px;
      padding: 0 10px;
      vertical-align: middle;
      line-height: 30px;
      font-size: 14px;
      font-weight: 400;
      transition: box-shadow .1s cubic-bezier(.4,1,.75,.9);
      -webkit-appearance: none;
      overflow: visible;
    }

    .textarea {
      height: 210px;
    }

    .input:focus {
        box-shadow: 0 0 0 1px #137cbd, 0 0 0 1px #137cbd, 0 0 0 3px rgba(19,124,189,.3), inset 0 0 0 1px rgba(16,22,26,.3), inset 0 1px 1px rgba(16,22,26,.4);
    }

    .header-text {
      color: #f5f8fa;
    }

    .btn {
      box-shadow: none;
      background-color: #506171;
      background-image: linear-gradient(180deg,hsla(0,0%,100%,.1),hsla(0,0%,100%,0));
      color: #fff;
      border-color: transparent;
      margin-left: 5px;
      margin-right: 5px;
      display: inline-flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      padding: 5px 10px;
      vertical-align: middle;
      text-align: left;
      font-size: 14px;
      min-width: 30px;
      min-height: 30px;
      -webkit-appearance: button;
      text-transform: none;
      overflow: visible;
      line-height: 1.15;
    }

    .btn:hover {
      background-color: #45596d;
      color: #fff;
    }

    .btn:disabled {
      box-shadow: none;
      background-image: none;
      color: hsla(0,0%,100%,.3);
      border-color: transparent;
      background-color: #50617180;
      cursor: not-allowed;
    }

    .btn-green {
      background-color: #0f9960;
      color: #fff;
    }

    .btn-green:hover {
      background-color: #0d8050;
      color: #fff;
    }

    .btn-clean {
      position: absolute;
      top: 0;
      right: 0;
      margin: 0;
      border-radius: 0 0 0 3px;
    }

    .btn-clean:hover, .btn-clean:focus, .btn-clean:active {
      background-color: #509cba;
    }

    .empty {
      margin: auto;
      width: 100%;
      text-align: center;
      text-transform: none;
      line-height: 1.15;
      font-size: 30px;
      color: hsla(0,0%,100%,.3);
    }

    .ws-form {
      margin: 0 20px;
      text-align: center;
    }

    .input-wrapper {
      display: inline-block;
      text-align: left;
    }

    .auth-input-bar {
      /* when uses textarea */
      /* min-height: 275px; */
      min-height: 185px;
    }

    .checkbox {
      display: inline-flex;
    }

    .checkbox input[type="checkbox"] {
      display: inline-block;
      position: relative;
      width: 50px;
      height: 26px;
      background: #ccd1da;
      box-shadow: inset 0 2px 3px rgba(0,0,0,.2);
      border-radius: 13px;
      -webkit-appearance: none;
      outline: none;
      cursor: pointer;
      transition: all .3s;
    }

    .checkbox input[type="checkbox"]:after {
      display: block;
      content: '';
      position: relative;
      top: 2px;
      left: 2px;
      width: 22px;
      height: 22px;
      border-radius: 11px;
      background: #fafafa;
      box-shadow: 0 2px 5px rgba(0,0,0,.3);
    }

    .checkbox input[type="checkbox"]:checked {
      padding-left: 24px;
      background: #509cba;
    }

    .checkbox__text {
      position: relative;
      display: inline-block;
      padding: 7px 0 0 10px;
      cursor: pointer;
      color: #fff;
    }

    .checkbox-bar {
      text-align: left;
    }
  </style>
</head>

<body class="body">
  <h1 class="header-text">BFX WEB SOCKET TESTER</h1>

  <form class="ws-form">
    <div>
      <p class="input-wrapper">
        <b class="header-text">WS address:</b><br>
        <input id="ws-address" class="input" type="text" size="50" placeholder="WS address:">
      </p>
    </div>
    <div class="auth-input-bar">
      <p class="input-wrapper token-wrapper">
        <b class="header-text">Token:</b><br>
        <!-- <textarea rows="8" cols="47" id="token" class="input textarea" type="text" placeholder="TOKEN:"></textarea> -->
        <input id="token" class="input" type="text" size="50" placeholder="TOKEN:">
      </p>
      <p class="input-wrapper base-auth-wrapper">
        <b class="header-text">Email:</b><br>
        <input id="email" class="input" type="text" size="50" placeholder="Email:">
      </p>
      <p class="input-wrapper base-auth-wrapper">
        <b class="header-text">Password:</b><br>
        <input id="password" class="input" type="text" size="50" placeholder="Password:">
      </p>
    </div>
  
    <div class="checkbox-bar">
      <p>
        <label class="checkbox">
          <input id="is-used-token" type="checkbox"/>
          <span class="checkbox__text">USE TOKEN</span>
        </label>
      </p>
  
      <p>
        <label class="checkbox">
          <input id="is-sub-account" type="checkbox"/>
          <span class="checkbox__text">SUB-ACCOUNT</span>
        </label>
      </p>
    </div>
  
      <p>
        <button id="btn-connect" class="btn btn-green" type="button">CONNECT</button>
        <button id="btn-login" class="btn" type="button" disabled>SIGN IN</button>
        <button id="btn-sync-now" class="btn" type="button" disabled>SYNC NOW</button>
      </p>
  </form>

  <div id="output" class="output">
    <button id="btn-clean" class="btn btn-clean" type="button">CLEAN</button>
    <div id="empty" class="empty">EMPTY</div>
  </div>
</body>

<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker
        .register('serviceWorker.js')
        .then(res => console.log('Service worker registered'))
        .catch(err => console.log('Service worker not registered', err))
    })
  }

  window.addEventListener('load', () => {
    console.log('[LOAD]')

    const output = document.getElementById('output')
    const empty = document.getElementById('empty')
    const tokenInput = document.getElementById('token')
    const emailInput = document.getElementById('email')
    const passwordInput = document.getElementById('password')
    const isUsedTokenCheckbox = document.getElementById('is-used-token')
    const isSubAccountCheckbox = document.getElementById('is-sub-account')
    const wsAddressInput = document.getElementById('ws-address')
    const loginBtn = document.getElementById('btn-login')
    const syncNowBtn = document.getElementById('btn-sync-now')
    const connectBtn = document.getElementById('btn-connect')
    const cleanBtn = document.getElementById('btn-clean')

    const baseAuthWrapper = document.getElementsByClassName('base-auth-wrapper')
    const tokenWrapper = document.getElementsByClassName('token-wrapper')

    tokenInput.value = localStorage.getItem('token')
    emailInput.value = localStorage.getItem('email')
    passwordInput.value = localStorage.getItem('password')
    isUsedTokenCheckbox.checked = localStorage.getItem('isUsedToken')
    isSubAccountCheckbox.checked = localStorage.getItem('isSubAccount')
    wsAddressInput.value = localStorage.getItem('wsAddress') || 'ws://127.0.0.1:34343/ws'

    const switchAuthMode = () => {
      const isUsedToken = !!isUsedTokenCheckbox.checked

      for (const elem of baseAuthWrapper) {
        elem.style.display = isUsedToken ? 'none' : 'inline-block'
      }
      for (const elem of tokenWrapper) {
        elem.style.display = isUsedToken ? 'inline-block' : 'none'
      }

      isSubAccountCheckbox.disabled = isUsedToken
      isSubAccountCheckbox.closest('label')
        .style.opacity = isUsedToken ? 0.25 : 1
    }
    isUsedTokenCheckbox.onclick = switchAuthMode
    switchAuthMode()

    const heartbeat = (websocket) => {
      clearTimeout(websocket.pingTimeout)

      websocket.pingTimeout = setTimeout(() => {
        websocket.close()
      }, 10000 + 1000)
    }

    const disableBtn = (elem) => {
      elem.classList.add("btn-disabled")
      elem.disabled = true
    }

    const enableBtn = (elem) => {
      elem.classList.remove("btn-disabled")
      elem.disabled = false
    }

    const stringify = (message) => {
      return typeof message !== 'string'
        ? JSON.stringify(message, null, 2)
        : message
    }

    const serializ = (message) => {
      try {
        const deserialized = JSON.parse(message)

        return stringify(deserialized)
      } catch (err) {
        return stringify(message)
      }
    }

    const getMess = (message, styles = {}) => {
      const mess = serializ(message)
      const _styles = {
        display: 'inline',
        'white-space': 'pre-wrap',
        ...styles
      }

      const stylesArr = Object.entries(_styles)
      const styleProps = stylesArr.reduce((accum, [key, val]) => {
        if (
          !val ||
          typeof val !== 'string'
        ) {
          return accum
        }

        return `${accum} ${key}: ${val};`
      }, '')
      const style = styleProps
        ? ` style="${styleProps}"`
        : ''

      return `<pre${style}>${mess}</pre>`
    }

    const writeToScreen = (data = []) => {
      if (!Array.isArray(data)) {
        return
      }

      const pre = document.createElement('p')

      pre.style.wordWrap = 'break-word'
      pre.style.color = '#fff'
      pre.innerHTML = data.reduce((accum, obj) => {
        const { mess = '', styles: s } = { ...obj }
        const styles = { ...s }

        return accum + getMess(mess, styles)
      }, '')

      output.insertBefore(pre, output.firstChild)
      empty.remove()
      output.style.display = 'block'
    }

    const rpcReq = (websocket, method = '', params = {}) => {
      const token = tokenInput.value
      const email = emailInput.value
      const password = passwordInput.value
      const isUsedToken = !!isUsedTokenCheckbox.checked
      const isSubAccount = !!isSubAccountCheckbox.checked

      localStorage.setItem('token', token)
      localStorage.setItem('email', email)
      localStorage.setItem('password', password)
      localStorage.setItem('isUsedToken', isUsedToken)
      localStorage.setItem('isSubAccount', isSubAccount)

      const auth = isUsedToken
        ? { token }
        : {
          email,
          password,
          isSubAccount
        }

      const data = {
        auth,
        method,
        params
      }
      const mess = JSON.stringify(data)

      writeToScreen([
        {
          mess: '[SENT]:',
          styles: { color: 'violet', 'margin-right': '5px' }
        },
        { mess }
      ])
      websocket.send(mess)
    }

    const logErr = (err) => {
      console.log('[ERR_WS]', err)

      writeToScreen([
        {
          mess: '[ERROR]:',
          styles: { color: 'red', 'margin-right': '5px' }
        },
        { mess: err.message || JSON.stringify(err) }
      ])
    }

    let isConnected = false
    let websocket = null
    let pingCount = 0

    connectBtn.onclick = () => {
      if (isConnected) {
        if (websocket) {
          websocket.close()
        }

        connectBtn.firstChild.data = 'CONNECT'
        isConnected = false

        return
      }

      connectBtn.firstChild.data = 'DISCONNECT'
      isConnected = true

      const wsAddress = wsAddressInput.value
      localStorage.setItem('wsAddress', wsAddress)

      websocket = new WebSocket(wsAddress)

      websocket.onopen = (e) => {
        heartbeat(websocket)

        writeToScreen([
          {
            mess: '[CONNECTED]',
            styles: { color: '#3d3dff' }
          }
        ])

        enableBtn(loginBtn)
        enableBtn(syncNowBtn)
      }
      websocket.onclose = (e) => {
        if (e.wasClean) {
          writeToScreen([
            {
              mess: '[DISCONNECTED]:',
              styles: { color: 'yellow', 'margin-right': '5px' }
            },
            { mess: 'connection closed clean' }
          ])
        } else {
          writeToScreen(
            '[DISCONNECTED]',
            { color: 'yellow' }
          )
        }

        writeToScreen([
          {
            mess: '[CODE]:',
            styles: { color: 'yellow', 'margin-right': '5px' }
          },
          {
            mess: event.code,
            styles: { 'margin-right': '5px' }
          },
          {
            mess: '[REASON]:',
            styles: { color: 'yellow', 'margin-right': '5px' }
          },
          { mess: e.reason }
        ])

        disableBtn(loginBtn)
        disableBtn(syncNowBtn)
        connectBtn.firstChild.data = 'CONNECT'
        isConnected = false
      }
      websocket.onmessage = (e) => {
        try {
          const data = { ...JSON.parse(e.data) }

          if (data.action === '__ping__') {
            const hasPing = /\[PING.*\]/.test(output.firstChild.innerHTML)

            if (hasPing) {
              output.firstChild.remove()

              pingCount += 1
            } else {
              pingCount = 1
            }

            writeToScreen([
              {
                mess: `[PING]${hasPing ? ':' : ''}`,
                styles: { color: '#d0ff00', 'margin-right': '5px' }
              },
              { mess: hasPing ? String(pingCount) : '' }
            ])

            heartbeat(websocket)

            return
          }
        } catch (err) {
          logErr(err)
        }

        writeToScreen([
          {
            mess: '[RESPONDED]:',
            styles: { color: '#00ff82', 'margin-right': '5px' }
          },
          { mess: e.data }
        ])
      }
      websocket.onerror = (err) => {
        logErr(err)

        websocket.close()
      }
    }

    loginBtn.onclick = () => {
      if (!isConnected) {
        return
      }

      rpcReq(websocket, 'signIn')
    }
    syncNowBtn.onclick = () => {
      if (!isConnected) {
        return
      }

      rpcReq(websocket, 'syncNow')
    }
    cleanBtn.onclick = () => {
      while (
        output.hasChildNodes()
      ) {
        output.removeChild(output.firstChild)
      }

      output.appendChild(cleanBtn)
      output.appendChild(empty)
    }
  })
</script>

</html>